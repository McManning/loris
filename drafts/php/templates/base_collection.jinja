<?php
namespace Loris\Resource\Base;

class {{ id }} extends MetaCollection
{
    const URI = '{{ uri }}';

    public $collection = null; // Array({{ properties.collection.resource }})
    protected $expansions = null; // Array

    /**
     * Track the properties that are used as our collections 
     * distinct identifier (one or composite). Each match
     * within URI must exist within this list. 
     */
    private $_id = array(
        '{{ id_keys|join('\', \'') }}'
    );
    {# ' <- just to fix broken highlighting :) #}

    // Properties

{% for name, property in properties|dictsort %}
    {% if name in id_keys %}
    {% if property.description %}
    /** 
     * {{ property.description|replace('\n', '\n     * ') }}
     * type: {{ property.format if property.format else property.type }}
     */
    {% else %}
    /** type: {{ property.type }} */
    {% endif %}
    public ${{ name }} = null;
    {% endif %}
{% endfor %}

    /**
     * @param array $ids Unique identifiers for this collection
     * @param integer $page Currently page of the collection to query (1-indexed)
     * @param integer $limit Number of results per collection page 
     */
    function __construct($ids = null, $page, $limit)
    {
        parent::__construct($ids, self::URI, $page, $limit);
    }

    /**
     *
     * @param array({{ id }}) ${{ id|camelcase|plural }}
     */
    public static function query(array ${{ id|camelcase|plural }})
    {
        throw new \Exception(
            'Base\\{{ id }}::query() cannot be called directly.'
        );
    }

    /**
     *
     * @param array({{ id }}) ${{ id|camelcase|plural }}
     * @param array $results
     */
    public static function postQuery(array ${{ id|camelcase|plural }}, array $results)
    {
        // Gather {{ resource.id|plural }} that have been hydrated from all 
        // collections and query for all simultaneously.
        $items = array();

        foreach (${{ id|camelcase|plural }} as ${{ id|camelcase }}) {
            ${{ id|camelcase }}->fromResults(
                $results[${{ id|camelcase }}->id()]
            );

            if (count(${{ id|camelcase }}->collection) > 0) {
                ${{ resource.id|camelcase|plural }} = array_merge(
                    ${{ resource.id|camelcase|plural }}, 
                    ${{ id|camelcase }}->collection
                );
            }
        }

        if (count(${{ resource.id|camelcase|plural }}) > 0) {
            
            // Resolve model to either a {{ resource.id }} or ExternalResource
            ${{ resource.id|camelcase }}Model = \Loris\Discovery::find('{{ resource.uri }}');

            // Execute query for set of resources
            call_user_func(
                array(${{ resource.id|camelcase }}Model->class, 'query'), 
                ${{ resource.id|camelcase|plural }}
            );
        }
    }

    /**
     * @param array $results
     */
    public function fromResults(array $results)
    {
        // Hydrate meta attributes
        $this->id($results['id']);
        $this->meta->page = intval($results['page']);
        $this->meta->limit = intval($results['limit']);
        $this->meta->total = intval($results['total']);

        $this->collection = array();

        // Resolve resource URI into a model
        ${{ resource.id|camelcase }}Model = \Loris\Discovery::find('{{ resource.uri }}');

        // Add a {{ resource.id }} for each ID
        foreach ($results['ids'] as $id) {
            // Note we resolve the model here instead of doExpansions
            // as no matter what, if a collection is hydrated, the
            // collection items must also be hydrated. 
            ${{ resource.id|camelcase }} = new ${{ resource.id|camelcase }}Model->class($id);

            $this->collection[] = ${{ resource.id|camelcase }};
        }

        $this->doExpansions();
    }

    /**
     *
     * @param array $resources
     */
    public function expand(array $resources)
    {
        $this->expansions = $resources;
    }

    /**
     * Perform actual expansions after hydration, in case we dynamically
     * add additional resource references while hydrating from the data store
     * (e.g. resources stored in Arrays or Objects)
     */
    private function doExpansions()
    {
        if ($this->expansions === null) {
            return;
        }

        foreach ($this->collection as ${{ resource.id|camelcase }}) {
            ${{ resource.id|camelcase }}->expand($this->expansions);
        }
    }

    /**
     * @return stdClass
     */
    public function serialize()
    {
        // Get serialized data from MetaCollection
        $serialized = parent::serialize();

        // Add a collection if we've been hydrated
        if ($this->collection) {
            $serialized->collection = array();

            // Serialize all of our {{ resource.id|plural }}
            foreach ($this->collection as ${{ resource.id|camelcase }})
            {
                $serialized->collection[] = ${{ resource.id|camelcase }}->serialize();
            }
        }
        
        return $serialized;
    }
}
