
Need to think about resources like:
{
    prop1: 'foo',
    prop2: 'bar',
    commitments: [
        {
            foo: 'blah',
            bar: 5
        },
        ...
    ],
    payments: [
        {
            blah: 'blah',
            meh: true
        },
        ...
    ]
}

theoretically, multiple rowset returns, each rowset containing data to append. 
First rowset is setting properties of the main resource, next rowset is commitment line items, third rowset is payment line items. Each rowset may include multiple 'id' fields so it can handle many results coming back.

So rowsets:
[ id, prop1, prop2 ]
[ id, foo, bar ]
[ id, blah, meh ]

and then hydration does something like:

# Hydrate properties
for row in rowset[0]:
    person = persons.find(row.id)
    person.from_row(row)

# Hydrate commitments
for row in rowset[1]:
    person = persons.find(row.id)
    person.???(row)

# Hydrate payments
# Same as commitments

Maybe it'd be easier to create a nested relationship BEFORE passing to the hydrate. So if something returns multiple rowsets, we rebuild it as a nested array set. The assumption, of course, is that rowset 0 only includes one instance of every resource, and rowsets 1-N have IDs that must be in rowset 0...

Maybe reformat as a generic:
{
    [ID] = {
        rowsets: [
            [
                { id, prop1, prop2 }
            ],
            [
                {id, foo, bar},
                {id, foo, bar}
            ],
            [
                {id, blah, meh}
            ]
        ]
    }
}
So we group EVERYTHING by the ID field, and then push rowsets to each resource that matches the ID. Hydration will then hydrate using rowsets[0] for the main object (which could be more than one, if the main object is actually a list of objects), rowsets[1-N] for attributes that are also objects and not relationships. 












