#! python3

###
# Compiler for Swagger YAML files. This will iterate 
# spec components and dump them into one spec.yaml file. 
#
# @author Chase McManning
###

import os
import re

import glob
import time
from datetime import datetime

import yaml # pip install pyyaml || easy_install pyyaml
import markdown2 # easy_install markdown2 
import json

# Template management for rendering static API documentation
from jinja2 import Environment, FileSystemLoader # easy_install Jinja2

# Tracker for changes in source files. Basically just a big glob
# of filenames/mtimes which we then regenerate and compare against
# the prior glob.
sources_hash = ''

def generate_documentation(spec):
    """Use Jinja2 to render a static API documentation page. 

    This is written because our API is too complex for Swagger UI to handle (hah..) 
    and their frontend-based rendering takes roughly 20 minutes to parse through it
    all (very heavy usage of Angular libraries and on-the-fly rendering). Of course,
    the assumption in this implementation (for now) is that the spec is valid 
    and complete.

    Eventually this should also allow us to document unique behaviors to our  
    endpoints (expansions, searches, ACLs) a little clearer, while ignoring the features
    of the Swagger spec that we don't use (OAuth, lot of JSON-schema features, etc)
    """
    
    # Compile the Jinja template. This only needs to be done once. 
    j2_env = Environment(
        loader=FileSystemLoader(os.path.dirname(os.path.abspath(__file__)))
    )

    # create a custom filter for Markdown support
    j2_env.filters['markdown'] = markdown2.markdown

    # Load resources into fragment files
    template = j2_env.get_template('templates/fragment.html')
    json_template = j2_env.get_template('templates/json.html')

    for id, properties in spec['definitions'].items():
        with open('dist/fragments/{}.html'.format(id.lower()), 'w') as f:
            f.write(re.sub('(\s+|<!--.*?-->)', ' ', template.render(
                id=id,
                resource=properties
            )))

        # Also compile into JSON, because why not
        with open('dist/fragments/{}.json'.format(id.lower()), 'w') as f:
            #try:
            print('Writing JSON for [{}]'.format(id.lower()))
            rendered = json.loads(json_template.render(
                id=id,
                resource=properties,
                resources=spec['definitions']
            ))
            #except e:
            #    print('Failed to JSONify resource [{}]'.format(id.lower()))
            #    rendered = {}

            
            f.write(json.dumps(rendered, indent=4))

    # Iterate resources and organize into our known endpoints
    resources_by_endpoint = dict(Other = dict())

    # Build an entry for each known endpoint
    for endpoint, properties in spec['endpoints'].items():
        resources_by_endpoint[endpoint] = dict()

    # Sort resources into the endpoints 
    for id, definition in spec['definitions'].items():
        if 'x-endpoint' not in definition:
            endpoint = 'Other'
        else:
            endpoint = definition['x-endpoint']
        
        if endpoint not in resources_by_endpoint:
            raise Exception('Resource [{}] using unknown x-endpoint [{}]'.format(id, endpoint))

        resources_by_endpoint[endpoint][id] = definition

    # Split each endpoint into a different page
    template = j2_env.get_template('templates/routes.html')
    resources_template = j2_env.get_template('templates/resources.html')

    for endpoint, properties in spec['endpoints'].items():
        with open('dist/routes-{}.html'.format(endpoint.lower()), 'w') as f:
            f.write(template.render(
                endpoint_id=endpoint, 
                endpoint=properties,
                api=spec
            ))

    # Different list, since we also include some extras (e.g. Other)
    for endpoint, resources in resources_by_endpoint.items():
        with open('dist/resources-{}.html'.format(endpoint.lower()), 'w') as f:
            f.write(resources_template.render(
                endpoint_id=endpoint,
                endpoint=properties,
                resources=resources,
                api=spec
            ))

    # Build introduction page
    template = j2_env.get_template('templates/introduction.html')
    with open('dist/index.html', 'w') as f:
        f.write(template.render(
            api=spec
        ))

    # Build examples page
    template = j2_env.get_template('templates/examples.html')
    with open('dist/examples.html', 'w') as f:
        f.write(template.render(
            api=spec
        ))

    # Build test page
    template = j2_env.get_template('templates/test.html')
    with open('dist/test.html', 'w') as f:
        f.write(template.render(
            api=spec
        ))

    # TODO: Build resource page for each endpoint? (Or single page for all resources?)



def compile_yaml():
    spec = '# Generated by compile.py at {}\n\n'.format(datetime.now())

    print('Loading YAML spec resources...')

    # Include header
    with open('spec/Header.yaml', 'r') as f:
        spec += f.read()

    # Include path files
    spec += '\nendpoints:\n'
    for path in glob.glob('spec/paths/*.yaml'):
        with open(path, 'r') as f:
            spec += '\n  # {}\n'.format(path)
            spec += f.read()

    # Include definition files
    spec += '\ndefinitions:\n'
    for path in glob.glob('spec/definitions/*.yaml'):
        with open(path, 'r') as f:
            spec += '\n  # {}\n'.format(path)
            spec += f.read()

    yaml_spec = yaml.load(spec)

    outfile = 'dist/spec-{}'.format(
        yaml_spec['info']['version']
    )

    # Write out the compiled YAML spec
    with open(outfile + '.yaml', 'w') as f:
        print('Writing {} spec to {}.yaml...'.format(
            yaml_spec['info']['title'], 
            outfile
        ))
        f.write(spec)

    # Cross-compile the spec to JSON as well
    with open(outfile + '.json', 'w') as f:
        print('Writing {} spec to {}.json...'.format(
            yaml_spec['info']['title'], 
            outfile
        ))
        f.write(json.dumps(yaml_spec, indent=4))

    # Generate static documentation as well
    print('Generating static documentation...')
    generate_documentation(yaml_spec)

    print('Finished compiling spec!')
    print('* Hosted at {}{}'.format(yaml_spec['host'], yaml_spec['basePath']))
    print('* {} Endpoints'.format(len(yaml_spec['endpoints'])))
    print('* {} Definitions'.format(len(yaml_spec['definitions'])))

def has_changed_sources():
    global sources_hash
    new_hash = ''
    for path in glob.glob('spec/paths/*.yaml'):
        new_hash += path
        new_hash += str(os.stat(path).st_mtime)

    for path in glob.glob('spec/definitions/*.yaml'):
        new_hash += path
        new_hash += str(os.stat(path).st_mtime)

    # Also check for changes in Jinja templates, as those 
    # should also trigger a recompile (to update output)
    for path in glob.glob('templates/*.html'):
        new_hash += path
        new_hash += str(os.stat(path).st_mtime)

    if new_hash != sources_hash:
        sources_hash = new_hash
        return True

    return False

if __name__ == '__main__':

    try:
        while True:
            # Whenever on-disk files change, recompile
            if (has_changed_sources()):
                compile_yaml()
                print('Watching for changes...')

            time.sleep(1)

    except KeyboardInterrupt:
        pass

